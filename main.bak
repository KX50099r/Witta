from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import asyncio
import logging
from pathlib import Path
import sys
import sys
from pathlib import Path

# Dynamically add the witta-core directory to sys.path
sys.path.append(str(Path(__file__).resolve().parent / "witta-core"))

# Add witta-core to the Python path
# sys.path.append(str(Path.cwd() / "witta-core"))

from app.core.orchestrator import main as orchestrator_main

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(message)s",
    handlers=[logging.FileHandler("server.log"), logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI()

# Enable CORS for testing (adjust origins in production)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Update with specific domains in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize orchestrator
orchestrator = orchestrator_main

@app.on_event("startup")
async def startup_event():
    logger.info("Server is starting...")
    asyncio.create_task(periodic_task_scheduler())

async def periodic_task_scheduler():
    while True:
        logger.info("Running periodic tasks")
        # Example: Automatically add a task every 60 seconds
        await orchestrator.add_task("fetch_crypto_data", {"symbol": "BTC"})
        await asyncio.sleep(60)

@app.get("/")
async def root():
    return {"message": "Server is running"}

@app.post("/tasks/")
async def add_task(task_type: str, payload: dict):
    try:
        # Add a task to the orchestrator
        await orchestrator.add_task(task_type, payload)
        return {"status": "Task added"}
    except Exception as e:
        logger.error(f"Error adding task: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tasks/{task_id}")
async def get_task_status(task_id: int):
    # Check task status in orchestrator
    if task_id in orchestrator.task_results:
        return orchestrator.task_results[task_id]
    else:
        raise HTTPException(status_code=404, detail="Task not found")

@app.get("/run/")
async def run_tasks():
    try:
        # Run the orchestrator
        asyncio.create_task(orchestrator.run())
        return {"status": "Task execution started"}
    except Exception as e:
        logger.error(f"Error running tasks: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/logs")
async def get_logs():
    try:
        with open("server.log", "r") as log_file:
            return {"logs": log_file.readlines()[-20:]}  # Return the last 20 log lines
    except FileNotFoundError:
        return {"logs": []}

@app.get("/health")
async def health_check():
    return {"status": "ok", "tasks_in_queue": orchestrator.task_queue.qsize()}
